Detalii de implementare:

  Pentru toate subpunctele am tinut cont de transformarile din plan in matrice.
In plan, x este coloana, iar y este linia. Pe parcursul implementarii se pot 
observa schimbari intre x si y din acest motiv. Pentru transformarile de la resize,
s-a considerat ca in planul xOy matricea incepe de la 0 si merge pana la p-1 si q-1.
Apoi, dupa aplicarea transformarilor, am lucrat direct pe matrice(cu indici de la 1).

Primul task:
  La primul task am implementat aproximarea pixelului astfel incat sa fie mereu cel
mai apropiat de punctul dat. Singurul imepdiment a fost faptul ca aproximarea din 
teste nu este exact functia round(X), asa ca a trebuit sa adaptez pentru cazul in
care partea fractionara este 0.5.
  Pentru resize s-a folosit tehnica descrisa la inceput. Vectorul rez este adunat
cu 1 la un moment dat, din acest motiv.

Al doilea task:
  La al doilea task am implementat asemenea indicatiilor totul. Nu prea am comentarii
pe cod, intrucat scheletul este foarte explicit. Cel mai mare obstacol a fost sa imi
dau seama ca indicii se tot interschimba(motivul mentionat la inceput). De asemenea,
la inceput trebuie facuta o conversie la double, altfel rezultatul nu este bun.

Al treilea task:
  Pentru toate task-urile am copiat pseudocodul, incercand sa urmez indicatiile.
  La toate subpunctele tin minte matricile anterioare(curente), de exemplu Vk, iar 
matricea curenta(urmatoare) este Vk+1(asa fac si pentru W etc.).
  Pentru primul subtask am implementat QR din laborator(GS modificat), ca sa obtin
din punct de vedere dimensional matrici bune(qr din octave nu ofera cea mai buna
solutie dimensional, intrucat testate cu matrici W si V de 3x2, se obtin matrici 
de 3x3). La final, scot cele doua spatii(2 seturi de m matrici) care verifica
conditiile de biortonormalitate. De asemenea, matricea S este inversabila(foarte 
important este faptul ca e patratica, din inmultirea lui W' cu V), de aceea am facut
artificiul inv(S.^(1/2)) ca S la -1/2.
  La al doilea task s-au urmarit analog indicatiile date. Fortez sigma(m+1) = inf
pentru a testa mai bine functia. Pentru un input normal, aceasta este deja construita
bine. Am mai dat A=Am etc.
  Pentru studiul convergentei la 3, am afisat si erorile:
  err =  4.8859
  err =  2.8476
  err =  10.670
  err =  7.6375
  err =  4.4911
  err =  0.64057
  err =  0.21875
  err =  0.050915
  err =  0.020634
  err =  0.0081907
  err =  0.0039405
  err =  0.0016572
  err =  0.00062812
  err =  0.00022774
  err =  0.000076472
  Au fost alese matrice cu rand. Se poate observa ca solutia converge relativ repede(tol = 0.00001).
  La al treilea task analog. Functia de transfer a fost calculata ca functie de transfer
de ordin redus. Testata de mine, metoda este convergenta.(loop-ul nu ruleaza la infinit).
